#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
#include <io.h>
#include <direct.h>
//#include <dir.h>

#include "pansi.h"    // header file generated by MIDL compiler
#include "panserver2.h"


// GLobal Vars

//DEF_VAR(Flag_TFR)

static char *get_tfr_inifile()
{
	static char inifile[256];
	getcwd(inifile, 256);
	strcat(inifile, "\\TFR.ini");
	return inifile;
}

static int create_tfr_inifile()
{
	FILE *fp;
	FILE *fp_ini, *fp_xml;
	char tfr_file[256];

	struct {
		short offset;
		short dtype;
		char str[256];
	} pars[1024];
	int npoint = 0;
	char buf[1024];

	int TotalLength;
	char TrfDataDir[80];

	int i, j;
	char *p, *p1;
	char infostr[80];
	char spstr[80];

	GetPrivateProfileString("system", "TFR", "", tfr_file, 256, GetIniFileName());
	if (tfr_file[0] == 0)
		return -1;

	strcat(tfr_file, "\\config.ini");
	fp_ini = fopen(tfr_file,"rt");
	if (fp_ini == NULL)
		return -1;

	p = strstr(tfr_file, "\\config.ini");
	*p = 0;

	strcat(tfr_file, "\\TfrChannelMap.xml");
	fp_xml = fopen(tfr_file, "rt");
	if (fp_xml == NULL)
	{
		fclose(fp_ini);
		return -1;
	}

	for (i = 0; i < 1024; i++) {
		pars[i].dtype = 0;
		pars[i].offset = 0;
		pars[i].str[0] = 0;
	}

	npoint = 0;
	TotalLength = 0;
	while (fgets(buf, 1024, fp_xml))
	{
		if (TotalLength == 0)
		{
			sprintf(spstr, "TotalLength=\"");
			p1 = strstr(buf, spstr);
			if (p1)
			{
				p = p1 + strlen(spstr);
				p1 = strstr(p, "\"");
				*p1 = 0;
				TotalLength = atoi(p);
				TotalLength += 12;		// 12 = HeadLength
				sprintf(infostr, "TotalLength = %d", TotalLength);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
			}
		}

		sprintf(spstr, "ChannelIndex=\"%d\"", npoint);
		p1 = strstr(buf, spstr);
		if (p1 == NULL)
			continue;

		p = buf;
		sprintf(spstr, "OffsetInDataBlock=\"");
		p1 = strstr(p, spstr);
		if (p1 == NULL)
			break;

		p = p1 + strlen(spstr);
		p1 = strstr(p, "\"");
		*p1 = 0;
		pars[npoint].offset = atoi(p);

		p = p1 + 1;
		sprintf(spstr, "DataType=\"");
		p1 = strstr(p, spstr);
		if (p1 == NULL)
			break;

		p = p1 + strlen(spstr);
		p1 = strstr(p, "\"");
		*p1 = 0;
		pars[npoint].dtype = atoi(p);

		npoint++;
	}
	sprintf(infostr, "xml lines = %d", npoint);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	fclose(fp_xml);

	TrfDataDir[0] = 0;
	while (fgets(buf, 1024, fp_ini))
	{
		if (TrfDataDir[0] == 0)
		{
			sprintf(spstr, "tfrFileStoreFolder2");
			p1 = strstr(buf, spstr);
			if (p1)
			{
				p = p1 + strlen(spstr);
				p1 = strstr(p, "=");
				while (*(++p1) == ' ');
				strcpy(TrfDataDir, p1);
				sprintf(infostr, "TrfDataDir = %s", TrfDataDir);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
			}
		}

		sprintf(spstr, "tfrCfg_AnalogChanInfo_");
		p1 = strstr(buf, spstr);
		if (p1 == NULL)
			continue;

		p = p1 + strlen(spstr);
		p1 = strstr(p, "=");
		if (p1 == NULL)
			continue;
		*p1 = 0;
		i = atoi(p)-1;
		if (i >= npoint || i < 0)
			continue;
		while (*(++p1) == ' ');
		p = p1;
		if ((p1 = strstr(p, "\r")) || (p1 = strstr(p, "\n")))	*p1 = 0;
		strcpy(pars[i].str, p);
		
		//sprintf(infostr, "[%d]=%s", i, pars[i].str);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	}
	fclose(fp_ini);

	fp = fopen(get_tfr_inifile(), "wt");

	if (fp == NULL)
		return -1;

	fputs("[profile]\n\n", fp);

	fprintf(fp, "TrfDataDir=%s", TrfDataDir);
	fprintf(fp, "TotalLength=%d\n", TotalLength);

	fputs("\n[config]\n\n", fp);
	j = 1;
	for (i = 0; i < npoint; i++)
	{
		int jump;
		int st_i;

		jump = 0;
		p = pars[i].str;
		for (st_i = 0; st_i < 10; st_i++)
		{
			sprintf(spstr, ",ST%d_", st_i);
			p1 = strstr(p, spstr);
			if (p1)
				break;
		}
		if (p1)
		{
			p = p1+strlen(spstr);
			p1 = strstr(p, "_");
			if (p1)
			{
				p1++;
				if (*p1 == '1' || *p1 == '3')
				{
					*(p1 - 1) = (*p1 == '1' ? 'H' : 'L');
					memmove(p1, p1+1, strlen(p1));
					pars[i].dtype += 2;
					jump = 1;
				}
			}
		}
		
		fprintf(fp, "tfrCfg_AnalogChanInfo_%d=%s,%d,%d\n", j, pars[i].str, pars[i].offset, pars[i].dtype);
		j++;
		if (jump)	i++;
	}
	fprintf(fp, "\ntfrCfg_AnalogChannel=%d\n", j-1);

	fclose(fp);

	return 0;
}

//==========================================================================
// TFR采集线程
//==========================================================================

static int TFR_setup()
{
	int i, j;

	int npoint;
	int size;

	int yxno;

	char str[256];
	
	//if (GetPrivateProfileString("system", "TFR", "", str, 256, GetIniFileName()) <= 0)
		//return -1;

	strcpy(pStation[0].name, "[TFR]");

	// CON
	//
	npoint = System.nCON;
	strcpy(ppYX[0][0].name, "（未定义）");
	for (j = 1; j < npoint; j++)
	{
		sprintf(ppYX[0][j].name, "CON_%04d", j);
	}

	// CAL
	//
	npoint = System.nCAL;
	strcpy(ppYC[0][0].name, "（未定义）");
	for (j = 1; j < npoint; j++)
	{
		sprintf(ppYC[0][j].name, "CAL_%04d", j);
	}

	create_tfr_inifile();

	npoint = GetPrivateProfileInt("config", "tfrCfg_AnalogChannel", 0, get_tfr_inifile());
	//ppYC[0][0].flag.padding = GetPrivateProfileInt("config", "TotalLength", 672, get_tfr_inifile());

	j = 1;
	yxno = 1;
	for (i = 0; i < npoint; i++)
	{
		char keyname[80];
		int n;
		char *p;
		//char s[256];
		sprintf(keyname, "tfrCfg_AnalogChanInfo_%d", i + 1);
		GetPrivateProfileString("config", keyname, "", str, 256, get_tfr_inifile());
		if (str[0] == 0)
			continue;

		/**/
		p = GetSubString(str, 2);
		if (*p)
			strncpy(ppYC[0][j].name, p, 41);
			
		p = GetSubString(str, 5);
		if (*p)
			strncpy(ppYC[0][j].unit, p, 11);

		p = GetSubString(str, 6);
		if (*p)
		{
			ppYC[0][j].k = atof(p);
			if (ppYC[0][j].k == 0)
				ppYC[0][j].k = 1;
		}

		p = GetSubString(str, 11);
		if (*p)
			ppYC[0][j].flag.padding = atoi(p); // 暂用flag.padding存储偏移量
				
		p = GetSubString(str, 12);
		if (*p)
			ppYC[0][j].fcache = atoi(p);  // 暂用fcache存储TFR数据类型：1,3 有符合，2,4无符号
		/**/
		
		p = ppYC[0][j].name;
		if (strncmp(p, "ST", 2) == 0 && p[strlen(p)-1] == 'L')
		{
			p[strlen(p)-1] = 0;
			strcpy(ppYC[0][j - 1].name, p);
			ppYC[0][j - 1].fcache = 8;
				//ppYC[0][j-1].fcache % 2 ? 2 * ppYC[0][j-1].fcache + 1 : 2 * ppYC[0][j-1].fcache;
				// (1,2,3,4) -> (3,4,7,8)
			//ppYC[0][j - 1].yc.status = VARSTATUS_bad;
			if (yxno < System.nCON)
			{
				ppYC[0][j-1].yxno = yxno;
				strcpy(ppYX[0][yxno].name, p);
				yxno++;
			}
		}
		else
		{
			if (j+1 >= System.nCAL)
				break;
			j++;
		}
	}

	//if (ppYC[0][0].flag.padding == 0 || ppYC[0][0].flag.padding < ppYC[0][j].flag.padding + （ppYC[0][j].fcache+1)/2）
	//	ppYC[0][j].flag.padding + （ppYC[0][j].fcache+1)/2

	sprintf(str, "%s, %f, %d, %d (%d)", ppYC[0][1].name, ppYC[0][1].k, ppYC[0][1].fcache, ppYC[0][1].flag.padding, yxno);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)str);
	DebugPrintln(str);

	//init_var(Flag_TFR, -1);

	return 0;
}

static char *get_new_tfr_file(char *path)
{
#if 0
	static char tfrfile[256];
	static unsigned short fdate0 = 0;
	static unsigned short ftime0 = 0;
	
	unsigned short fdate;
	unsigned short ftime;
	struct ffblk ffblk;
	int done;
	char fspec[256];

	//struct date now;
	//getdate(&now);
	fdate = ftime = 0;

	sprintf(fspec, "%s\\*.vmdata", path);
#ifdef _MSC_VER
	done = _findfirst(fspec, &ffblk, 0);
#else
	done = findfirst(fspec, &ffblk, 0);
#endif
	while (!done)
	{
		if (fdate < ffblk.ff_fdate)
		{
			fdate = ffblk.ff_fdate;
			ftime = ffblk.ff_ftime;
		}
		else if (fdate == ffblk.ff_fdate && ftime < ffblk.ff_ftime)
			ftime = ffblk.ff_ftime;

		done = findnext(&ffblk);
	}


	if (fdate == 0 && ftime == 0)
		return NULL;

	/*	
	if (fdate0 < fdate)
	{
		fdate0 = fdate;
		ftime0 = ftime;
	}
	else if (fdate0 == fdate && ftime0 < ftime)
		ftime0 = ftime;
	else
		return NULL;
	*/

	sprintf(tfrfile, "%s\\%s", path, ffblk.ff_name);
	return tfrfile;
#endif
}

static void handle_data(char *data, int block_size)
{
	int i, j;

	waitfor_mutex(Mutex_RT);
	for (j = 1; j < System.nCAL; j++)
	{
		int offset = ppYC[0][j].flag.padding;
		float k = ppYC[0][j].k;
		int data_t = ppYC[0][j].fcache;
		int nbyte = (data_t + 1) / 2;
		//int is_signed = data_t % 2 ? 1 : 0;
		int yxno = ppYC[0][j].yxno;

		unsigned char uc[4];
		unsigned long ul;
		//short value;
		unsigned kk;

		if (offset == 0)
			break;

		memcpy(uc, data + offset, nbyte);

		ul = uc[nbyte-1];
		kk = 256;
		for (i = nbyte - 1; i > 0; i--)
		{
			ul += kk * uc[i - 1];
			kk *= 256;
		}

		switch (data_t)
		{
		case 1:
			ppYC[0][j].yc.value =(char)ul;
			break;
		case 2:
			ppYC[0][j].yc.value =(unsigned char)ul;
			break;
		case 3:
			ppYC[0][j].yc.value = (short)ul;
			break;
		case 4:
			ppYC[0][j].yc.value = (unsigned short)ul;
			break;
		case 8:
			ppYC[0][j].yc.value = (unsigned long)ul;
			break;
		}
		if (k)
			ppYC[0][j].yc.value = k * ppYC[0][j].yc.value;
		
		if (yxno > 0)	// YX and Event
		{
			short new_value;
			struct date d;
			struct time t;
			ENEVENT event;

			float NormalValue = 0xFFFFFFFFUL;
			
			if (ppYC[0][j].yc.value == 0 || ppYC[0][j].yc.value == NormalValue)
				new_value = 0;
			else
				new_value = 1;

			if (new_value != ppYX[0][yxno].yx.value)
			{
				char infostr[80];
				unsigned long lv = ppYC[0][j].yc.value;

				ppYX[0][yxno].yx.value = new_value;

				//sprintf(infostr, "SOE： (%d) = %d", yxno, new_value);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);

				// Event
				memset(&event, 0, sizeof(ENEVENT));

				event.type = EVENTTYPE_ALARM;
				event.subtype = EVENTSUBTYPE_SOE;
				event.status = new_value ? EVENTSTATUS_SOE1 : EVENTSTATUS_SOE0;

				event.dtype = VARTYPE_YX;
				event.station = 0;
				event.point = yxno;

				sprintf(event.note, "\\ %02X %02X %02X %02X", 
					(lv & 0xff000000) >> 24, (lv & 0x00ff0000) >> 16, (lv & 0x0000ff00) >> 8, lv & 0x000000ff);

				getdate(&d);
				event.date.year = d.da_year;
				event.date.day = d.da_day;
				event.date.month = d.da_mon;
				gettime(&t);
				event.time.hour = t.ti_hour;
				event.time.minute = t.ti_min;
				event.time.second = t.ti_sec;
				event.time.hundsec = t.ti_hund;

				waitfor_mutex(Mutex_EVENT);
				memcpy(pEventBuf + Num_Event, &event, sizeof(ENEVENT));
				Num_Event++;
				if (Num_Event == MAXNUM_EVENT)
					memcpy(pEventBuf, pEventBuf + 1, sizeof(ENEVENT)*(Num_Event - 1));
				release_mutex(Mutex_EVENT);
			}
		}
	}

	release_mutex(Mutex_RT);
}

// TFR_Routine
//   
//	周期性读取TFR文件，将TFR值赋予“虚厂”，并判断是否有SOE事件

int WINAPI Routine_Virtual()
{
	char tfr_dir[256];
	char *tfr_file;
	int block_size;
	char *buf, *data;
	int has_data;
	char infostr[80];
	char filename_0[_MAX_FNAME];
	char filename[_MAX_FNAME];

	if (GetPrivateProfileString("system", "TFR", "", infostr, 256, GetIniFileName()) <= 0)
		return -1;
	
	if (TFR_setup() < 0)
		return - 1;

	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)"TFR线程启动");
	DebugPrintln(infostr);

	GetPrivateProfileString("profile", "TrfDataDir", "D:\\TFR", tfr_dir, 256, get_tfr_inifile());
	block_size = GetPrivateProfileInt("profile", "TotalLength", 684, get_tfr_inifile());
	buf = (char *)malloc(block_size);
	data = (char *)malloc(block_size);

	filename_0[0] = 0;
	inc_var(Count_FER);	
	while (get_var(Flag_FER))
	{
		FILE *fp;

		tfr_file = get_new_tfr_file(tfr_dir);
		if (tfr_file == NULL)
		{
			Sleep(1000);
			continue;
		}

		_splitpath(tfr_file, NULL, NULL, filename, NULL);
		fp = fopen(tfr_file, "rb");
		if (fp == NULL)
		{
			sprintf(infostr, "打不开TFR文件：%s", filename);
			//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			DebugPrintln(infostr);
			continue;
		}
		if (strcmp(filename, filename_0))
		{
			sprintf(infostr, "TFR文件：%s", filename);
			//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			DebugPrintln(infostr);
			strcpy(filename_0, filename);
		}

		has_data = 0;
		while (fread(buf, 1, block_size, fp) == block_size)
		{
			memcpy(data, buf, block_size);
			has_data = 1;
		}

		fclose(fp);

		if (has_data)
			handle_data(data, block_size);

		Sleep(1000);
	}

	free(buf);
	free(data);

	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)"TFR线程结束");
	DebugPrintln("TFR线程结束");

	//set_var(Flag_TFR, -1);
	dec_var(Count_FER);
	
	return 0L;
}

/*
static void TFR_Cleanup()
{
	char infostr[256];
	if (GetPrivateProfileString("system", "TFR", "", infostr, 256, GetIniFileName()) <= 0)
		return;

	if (get_var(Flag_TFR) == 1)
	{
		int i;
		set_var(Flag_TFR, 0);
		for (i = 0; i < 5; i++)
		{
			Sleep(200);
			if (get_var(Flag_TFR) == -1)
				break;
		}
	}

	close_var(Flag_TFR);

	return;
}
*/