#include <windows.h>
#include <winsock.h>
//#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
//#include <dir.h>
#include "rule_log.h"
#include "pansi.h"    // header file generated by MIDL compiler
#include "panserver2.h"

enum TYPE_TEL
{
	YTVAL_BACK = 0x0202,  //返回当前定值
	YTWRITE_STAUS = 0x0204,  //写定值操作结果
	YT_YC_TEL = 0x0303,  //遥信遥测报文
	SOE_TEL = 0x0404   //事件报文

};

#define BUFLEN 2048

char checkFrameFlag(unsigned char* srcBuf, int iCurrPos)
{
#define I870DEF4_APDU_START_CHARACTER 0x68
	if (srcBuf[iCurrPos] == I870DEF4_APDU_START_CHARACTER) //判断首字符是否等于0x68
	{
		return 1;
	}
	else
		return 0;
}

int getOneFrame(unsigned char* srcBuf, int iSrcLen, unsigned char*oneframeBuf, int  iOneframe_Len)
{
	//缓冲区不够完整一帧，返回0
	//确定完整一帧，返回1
	int iRet = 0;//返回值
	int iLeftLen = 0;//缓冲区剩余报文长度
	//最小报文帧长度
#define MIN_FRAME_LEN 6

	iLeftLen = iSrcLen;

	int iCurrPos = 0;//输出缓冲区当前位置标记

	//退出循环标记:（1）确定完整一帧，或（2）剩余长度小于最小帧长，或（3）剩余长度小于“报文长度字节”表示的长度，即可退出循环
	char bExit = 0;
	while (!bExit)
	{
		if (iLeftLen < MIN_FRAME_LEN)//小于最小帧长时，退出循环
		{
			iRet = 0;
			bExit = 1;//退出循环
		}
		else
		{
			if (checkFrameFlag(srcBuf, iCurrPos) == 0)
			{
				//首字符不等于0x68，需要记录输出信息
				iCurrPos++;
				iLeftLen = iSrcLen - iCurrPos;
				continue;
			}
			else if (checkFrameFlag(srcBuf, iCurrPos) == 1) //判断首字符是否等于0x68
			{
				//判断长度
				unsigned char iFrameLen = 0;
				iFrameLen = srcBuf[iCurrPos + 2] + 256 * srcBuf[iCurrPos + 3];
				//是否够完整一帧
				if (iLeftLen >= iFrameLen)
				{
					memcpy(oneframeBuf, &srcBuf[iCurrPos], iFrameLen); //取出一完整帧

					//printOneFrame(oneframeBuf, iFrameLen);
					iOneframe_Len = iFrameLen;//帧长

					iLeftLen = iSrcLen - iCurrPos - iFrameLen;//计算剩余长度，以便退出循环

					iCurrPos += iFrameLen;//当前位置移动

					iRet = 1;//确定完整一帧
					bExit = 1;//退出循环
				}
				else//剩余长度已经不够完整一帧
				{
					iRet = 0;//剩余长度已经不够
					bExit = 1;//退出循环
				}

			}//end else if 
		}//end else 

	}//end while


	return iRet;

}

//static int com_operation(SOCKET sock, long vid, float fv)
static int com_operation(SOCKET sock, int station, int point, int vtype, float fv)
{
	unsigned char sndbuf[BUFLEN];
	unsigned short len_snd;

	//int station = GetVarStation(vid);
	//int point = GetVarPoint(vid);
	//int vtype = GetVarType(vid);

	//if (vid == 0)
	//	return -1;

	memset(sndbuf, 0, BUFLEN);

	sndbuf[0] = sndbuf[1] = 0x68;

	if (vtype == VARTYPE_YX)
	{
		//if (point == pStation[station].yt_read)
		//{
		//	len_snd = 14;
		//	sndbuf[2] = LOBYTE(len_snd);
		//	sndbuf[3] = HIBYTE(len_snd);
		//	sndbuf[4] = 0x02;
		//	sndbuf[5] = 0x01;
		//	sndbuf[6] = sndbuf[7] = 0xFF;

		//	sndbuf[12] = sndbuf[13] = 0x86;

		//} 
		//else
		//{
			len_snd = 15;
			sndbuf[2] = LOBYTE(len_snd);
			sndbuf[3] = HIBYTE(len_snd);
			sndbuf[4] = sndbuf[5] = 0x01;
			sndbuf[6] = (point - pStation[station].yk_begin) / 16;
			sndbuf[7] = (point - pStation[station].yk_begin) % 16;
			sndbuf[8] = fv ? 1 : 0;

			sndbuf[13] = sndbuf[14] = 0x86;

		//}
	}
	else
	{
		int num_yk = pStation[station].yt_end - pStation[station].yt_begin + 1;
		int i;
		char infostr[256];

		len_snd = 4 * num_yk + 14;
		sndbuf[2] = LOBYTE(len_snd);
		sndbuf[3] = HIBYTE(len_snd);
		sndbuf[4] = 0x02;
		sndbuf[5] = 0x03;
		sndbuf[6] = LOBYTE(num_yk);
		sndbuf[7] = HIBYTE(num_yk);
		for (i = 0; i < num_yk; i++)
		{
			union {
				float f;
				char c[4];
			} v;
			if (point == pStation[station].yt_begin + i)
				v.f = fv;
			else
				v.f = ppYC[station][pStation[station].yt_begin + i].yc.value;

			sndbuf[8 + 4 * i] = v.c[0];
			sndbuf[8 + 4 * i + 1] = v.c[1];
			sndbuf[8 + 4 * i + 2] = v.c[2];
			sndbuf[8 + 4 * i + 3] = v.c[3];
		}
		sndbuf[4 * num_yk + 12] = sndbuf[4 * num_yk + 13] = 0x86;

		sprintf(infostr, "YK (%d, %d)\n", num_yk, point);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
	}

	if (send(sock, sndbuf, len_snd, 0) == SOCKET_ERROR)
	{
		//sprintf(infostr, "Opearation send failed. Error#%d\n", WSAGetLastError());
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		//set_var(VarID_OPER, 0);
		return -1;
	}
	WriteLog_Tele(station, sndbuf, len_snd, 0);
	//recv(sock, sndbuf, BUFLEN, 0);

	return 0;
}


int WINAPI Routine_XDSVG(int station)
{
	ppYX[station][0].yx.value = 0;
	SOCKET ConnectSocket;	// = INVALID_SOCKET;
	//struct addrinfo *result = NULL, hints;
	struct sockaddr_in addr;
	// 	struct timeval timeout;
	int iResult;
	char *ipstr;

	char infostr[240];
	char datafile[256];

	if (pStation[station].addr1[0] == 0 && pStation[station].addr2[0] == 0 && pStation[station].port == 0)
	{
		sprintf(infostr, "station(%d): 地址错误 (%s, %s, %d)\n", station,
			pStation[station].addr1, pStation[station].addr2, pStation[station].port);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
		return -1;
	}

	ipstr = pStation[station].addr2[0] ? pStation[station].addr2 : pStation[station].addr1;


	sprintf(datafile, ".\\facdata\\Lastvalues_%d.dat", station);

	sprintf(infostr, "#%d线程启动", station);

	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, 1);	
	inc_var(Count_FER);
	while (get_var(Flag_FER))
	{
		int fComStateChange;

		pStation[station].oper_point = 0;  //set_var(VarID_OPER, 0);
		fComStateChange = 0;

		// Connect to server.
		// Create a SOCKET for connecting to server
		ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (ConnectSocket == INVALID_SOCKET) {
			sprintf(infostr, "station(%d): socket failed (%ld)", station, WSAGetLastError());
			//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			DebugPrintln(infostr);
			return -1;
		}

		// 设置连接超时时间
		//linux下
		// 		timeout.tv_sec = 5;
		// 		timeout.tv_usec = 0;
		// 		setsockopt(ConnectSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));
		// 		setsockopt(ConnectSocket, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout));

		//windows下
		int timeout = 5000; //5s
		setsockopt(ConnectSocket, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
		setsockopt(ConnectSocket, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));


		addr.sin_family = AF_INET;
		addr.sin_port = htons(pStation[station].port);

		if (ipstr == pStation[station].addr1)
		{
			if (pStation[station].addr2[0])
				ipstr == pStation[station].addr2;
		}
		else
		{
			if (pStation[station].addr1[0])
				ipstr == pStation[station].addr1;
		}
		addr.sin_addr.s_addr = inet_addr(ipstr);

		//sprintf(infostr, "#%d连接:%s", station, ipstr);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);

		iResult = connect(ConnectSocket, (SOCKADDR*)&addr, sizeof(addr));
		if (iResult == SOCKET_ERROR) // 通道连接失败
		{
			closesocket(ConnectSocket);
			ConnectSocket = SOCKET_ERROR;

			if (ppYX[station][0].yx.value == 1)
			{
				//FILE *fp;

				waitfor_mutex(Mutex_RT);

				ppYX[station][0].yx.value = 0;

				release_mutex(Mutex_RT);

				sprintf(infostr, "#%d站连接中断!", station);
				WriteLog(station, "连接中断!\r\n");
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
			}

			Sleep(100);
			continue;
		}
		else	// 通道连接成功
		{
			SYSTEMTIME	systime;
			memset(&systime, 0x00, sizeof(systime));
			GetCurTime(&systime);
			sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d #%d站连接成功!", systime.wYear, systime.wMonth, systime.wDay,
				systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds, station);
			DebugPrintln(infostr);
			WriteLog(station, "连接成功!\r\n");

			waitfor_mutex(Mutex_RT);
			if (ppYX[station][0].yx.value == 0)
			{
				fComStateChange = 1;
				ppYX[station][0].yx.value = 1;
			}
			release_mutex(Mutex_RT);
		}

		while (get_var(Flag_FER))
		{
			unsigned char sndbuf[BUFLEN];
			unsigned char rcvbuf[BUFLEN];
			int len_snd, len_rcv;
			unsigned int n_yx, n_yc, n_event, n_yt, n_Ind, n_Alarm, n_SOE;
			unsigned int yx_offset, yc_offset, event_offset, Ind_offset, Alarm_offset, SOE_offset;
			unsigned int end_offset;
			unsigned int tel_type, operate_status;

			union {
				float f;
				char c[4];
			} fv;

			int i;
			int vid_oper;

			struct EVENTNO {
				unsigned short fault_no;
				unsigned short info_no;
			} *confirm_events;

			/*
			vid_oper = get_var(VarID_OPER);
			if (0)		//vid_oper)
			{
			sprintf(infostr, "Station %d, YK：%04X", GetVarStation(vid_oper), pStation[station].oper_value);	//Var_OPER);
			SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			}
			*/
			//if (vid_oper && GetVarStation(vid_oper) == station)
			if (pStation[station].oper_point > 0)
			{
				int point = pStation[station].oper_point;	//GetVarPoint(vid_oper);
				int vtype = pStation[station].oper_type;	//GetVarType(vid_oper);

				sprintf(infostr, "控制操作：%s (%d, %d) = %.2f", vtype == VARTYPE_YC ? "遥调" : "遥控", station, point, pStation[station].oper_value);	//Var_OPER);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
				strcat(infostr, "\r\n");
				WriteLog(station, infostr);
				//com_operation(ConnectSocket, vid_oper, Var_OPER);
				com_operation(ConnectSocket, station, point, vtype, pStation[station].oper_value);	//Var_OPER);

				pStation[station].oper_point = 0;  //set_var(VarID_OPER, 0);
			}

			if (fComStateChange)
			{
				fComStateChange = 0;

				// 【连接成功后代码在此】。。。
			}

			iResult = recv(ConnectSocket, rcvbuf, BUFLEN, 0);
			if (iResult == SOCKET_ERROR)
			{
				SYSTEMTIME	systime;
				memset(&systime, 0x00, sizeof(systime));
				GetCurTime(&systime);
				sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d recv()返回 SOCKET_ERROR，Error:%d", systime.wYear, systime.wMonth, systime.wDay,
					systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds, WSAGetLastError());
				DebugPrintln(infostr);
				WriteLog(station, "SOCKET_ERROR recv()返回 SOCKET_ERROR\r\n");

				ppYX[station][0].yx.value = 0;
				closesocket(ConnectSocket);
				Sleep(2000);
				break;
			}


			len_rcv = iResult;
			if (len_rcv == 0)
			{
				sprintf(infostr, "对端关闭连接，recv()返回 %d, WSAGetLastError() = %d", len_rcv, WSAGetLastError());
				DebugPrintln(infostr);
				WriteLog(station, "对端关闭连接，recv()返回0\r\n");

				ppYX[station][0].yx.value = 0;
				closesocket(ConnectSocket);
				Sleep(2000);
				break;
			}

			WriteLog_Tele(station, rcvbuf, len_rcv, 1);

			printf("len_rcv = %d ", len_rcv);
			for (int i = 0; i < len_rcv; i++)
			{
				printf("%02x ", rcvbuf[i]);
			}
			printf("\n");

			// 			if (len_rcv < 22)
			// 			{
			// 				Sleep(10);
			// 				continue;
			// 			}

			end_offset = len_rcv - 4;
			tel_type = rcvbuf[4] + 256 * rcvbuf[5];
			switch (tel_type)
			{
				case YT_YC_TEL:                  //0x0303正常的遥信遥测报文

					yx_offset = rcvbuf[6] + 256 * rcvbuf[7];
					yc_offset = rcvbuf[8] + 256 * rcvbuf[9];
					if (yc_offset)
					{
						n_yc = (end_offset - yc_offset) / 4;
						end_offset = yc_offset;
					}
					if (yx_offset)
					{
						n_yx = (end_offset - yx_offset) * 16;
						end_offset = yx_offset;
					}

					waitfor_mutex(Mutex_RT);

					for (i = 0; i < n_yx; i++)
					{
						unsigned short c;
						short new_value;

						if (i >= System.nYX - 1)
							break;

						c = rcvbuf[yx_offset + 2 * (i / 16)] + 256 * rcvbuf[yx_offset + 2 * (i / 16) + 1];
						//new_value = (c<<(i%16)) & 0x8000U ? 1 : 0;
						new_value = (c >> (i % 16)) & 0x0001U ? 1 : 0;

						if (new_value == ppYX[station][i + 1].yx.value)
							continue;
						ppYX[station][i + 1].yx.value = new_value;
					}
					for (i = 0; i < n_yc; i++)
					{
						if (i >= System.nYC - 1)
							break;
						fv.c[0] = rcvbuf[yc_offset + 4 * i];
						fv.c[1] = rcvbuf[yc_offset + 4 * i + 1];
						fv.c[2] = rcvbuf[yc_offset + 4 * i + 2];
						fv.c[3] = rcvbuf[yc_offset + 4 * i + 3];
						ppYC[station][i + 1].yc.value = fv.f;
					}

					release_mutex(Mutex_RT);
					break;

				//case YTVAL_BACK:              // 0x0202 返回遥调定值
				//	operate_status = rcvbuf[6] + 256 * rcvbuf[7];
				//	if (1 == operate_status)
				//	{
				//		printf("读取定值失败!!!\n");
				//		break;
				//	}
				//	n_yt = rcvbuf[8] + 256 * rcvbuf[9];
				//	for (i = 0; i < n_yt; i++)
				//	{
				//		fv.c[0] = rcvbuf[10 + 4 * i];
				//		fv.c[1] = rcvbuf[10 + 4 * i + 1];
				//		fv.c[2] = rcvbuf[10 + 4 * i + 2];
				//		fv.c[3] = rcvbuf[10 + 4 * i + 3];
				//		ppYC[station][pStation[station].yt_begin + i].yc.value = fv.f;

				//	}
				//	break;
				//case YTWRITE_STAUS:          //0x0204  写定值操作结果
				//	operate_status = rcvbuf[6] + 256 * rcvbuf[7];
				//    if (0 == operate_status)
				//    {
				//		printf("写定值成功!!!\n");
				//    } 
				//    else if (1 == operate_status)
				//    {
				//		printf("写定值失败，越线!!!");
				//    }
				//	else if (2 == operate_status)
				//	{	
				//		printf("写入文件失败!!!");
				//    }
				//	else
				//	{
				//		printf("tel_type = 0x0203,未识别的返回类型!!!");
				//	}
				//	break;
				case SOE_TEL:
					Ind_offset = rcvbuf[6] + 256 * rcvbuf[7];
					Alarm_offset = rcvbuf[8] + 256 * rcvbuf[9];
					SOE_offset = rcvbuf[10] + 256 * rcvbuf[11];

					n_Ind   = rcvbuf[6] + 256 * rcvbuf[7];  //ind事件个数
					n_Alarm = rcvbuf[8] + 256 * rcvbuf[9];  //alarm事件个数
					n_SOE   = rcvbuf[10] + 256 * rcvbuf[11]; //SOE事件个数
					break;
				default:
					printf("未识别的报文类型tel_type = %04x", tel_type);
					break;
			}
			yx_offset = rcvbuf[6] + 256 * rcvbuf[7];
			yc_offset = rcvbuf[8] + 256 * rcvbuf[9];

			event_offset = rcvbuf[8] + 256 * rcvbuf[9];
			n_event = rcvbuf[10] + 256 * rcvbuf[11];

			if (event_offset)
				end_offset = event_offset;

			if (yc_offset)
			{
				n_yc = (end_offset - yc_offset) / 4;
				end_offset = yc_offset;
			}
			if (yx_offset)
			{
				n_yx = (end_offset - yx_offset) * 16;
				end_offset = yx_offset;
			}

			waitfor_mutex(Mutex_RT);

			for (i = 0; i < n_yx; i++)
			{
				unsigned short c;
				short new_value;

				if (i >= System.nYX - 1)
					break;

				c = rcvbuf[yx_offset + 2 * (i / 16)] + 256 * rcvbuf[yx_offset + 2 * (i / 16) + 1];
				//new_value = (c<<(i%16)) & 0x8000U ? 1 : 0;
				new_value = (c >> (i % 16)) & 0x0001U ? 1 : 0;

				if (new_value == ppYX[station][i + 1].yx.value)
					continue;
				ppYX[station][i + 1].yx.value = new_value;
			}
			for (i = 0; i < n_yc; i++)
			{
				if (i >= System.nYC - 1)
					break;
				fv.c[0] = rcvbuf[yc_offset + 4 * i];
				fv.c[1] = rcvbuf[yc_offset + 4 * i + 1];
				fv.c[2] = rcvbuf[yc_offset + 4 * i + 2];
				fv.c[3] = rcvbuf[yc_offset + 4 * i + 3];
				ppYC[station][i + 1].yc.value = fv.f;
			}

			release_mutex(Mutex_RT);

			// 处理事件
			confirm_events = NULL;
			if (n_event)
				confirm_events = (struct EVENTNO *)malloc(sizeof(struct EVENTNO)*n_event);
			for (i = 0; i < n_event; i++)
			{
				struct SOE_DATA {
					unsigned char TYP;
					unsigned char NUM;
					unsigned char COT;
					unsigned char ADDR;
					unsigned char FUNC;
					unsigned char INF;
					unsigned char ST;
					unsigned char msL1;
					unsigned char msL2;
					unsigned char msH1;
					unsigned char msH2;
					unsigned char FANL;
					unsigned char FANH;
					unsigned char msL;
					unsigned char msH;
					unsigned char min;
					unsigned char hour;
					unsigned char day;
					unsigned char mon;
					unsigned char year;
					unsigned char SIN;
					unsigned char FLTTYP;
				} SOE_data;

				int num_fv;
				struct date d;
				struct time t;
				unsigned short ms, ms_1, ms_2;
				ENEVENT event;

				//int j;

				memcpy(&SOE_data, rcvbuf + event_offset, 22);
				num_fv = SOE_data.NUM - 1;
				event_offset += 22 + num_fv * 4;

				memset(&event, 0, sizeof(ENEVENT));

				event.type = EVENTTYPE_ALARM;
				if (SOE_data.TYP == 70)
					event.subtype = EVENTSUBTYPE_SIGNAL;
				else
					event.subtype = EVENTSUBTYPE_SOE;
				event.status = SOE_data.ST ? EVENTSTATUS_SOE1 : EVENTSTATUS_SOE0;

				event.dtype = VARTYPE_YX;
				event.station = station;
				event.point = SOE_data.INF;

				getdate(&d);
				event.date.year = d.da_year;
				event.date.day = d.da_day;
				event.date.month = d.da_mon;
				gettime(&t);
				event.time.hour = t.ti_hour;
				event.time.minute = t.ti_min;
				event.time.second = t.ti_sec;
				event.time.hundsec = t.ti_hund;

				ms = SOE_data.msH * 256 + SOE_data.msL;
				ms_1 = SOE_data.msH1 * 256 + SOE_data.msL1;
				ms_2 = SOE_data.msH2 * 256 + SOE_data.msL2;

				d.da_year = SOE_data.year;
				d.da_mon = SOE_data.mon;
				d.da_day = SOE_data.day;

				t.ti_hour = SOE_data.hour;
				t.ti_min = SOE_data.min;
				t.ti_sec = ms / 1000;

				ms = ms % 1000;
				ms_1 = ms_1 % 1000;
				ms_2 = ms_2 % 1000;

				if (SOE_data.TYP == 70)
				{
					sprintf(event.note, "%02u:%2u:%02u/%03u,%03u", t.ti_hour, t.ti_min, t.ti_sec, ms_1, ms_2);
					sprintf(infostr, "保护动作：(%d, %d) (%d) [%d]", station, event.point, SOE_data.ST, num_fv);
				}
				 
				{
					sprintf(event.note, "%02u:%2u:%02u.%03u", t.ti_hour, t.ti_min, t.ti_sec, ms);
					sprintf(infostr, "SOE事件：(%d, %d) (%d)", station, event.point, SOE_data.ST);
				}
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);

				waitfor_mutex(Mutex_EVENT);
				memcpy(pEventBuf + Num_Event, &event, sizeof(ENEVENT));
				Num_Event++;
				if (Num_Event == MAXNUM_EVENT)
					memcpy(pEventBuf, pEventBuf + 1, sizeof(ENEVENT)*(Num_Event - 1));
				release_mutex(Mutex_EVENT);

				confirm_events[i].fault_no = SOE_data.FANL + 256 * SOE_data.FANH;
				confirm_events[i].info_no = SOE_data.INF + 256 * SOE_data.FUNC;
			}

			if (confirm_events)
			{
				len_snd = 4 * n_event + 14;
				memset(sndbuf, 0, len_snd);
				sndbuf[0] = sndbuf[1] = 0x68;
				sndbuf[2] = LOBYTE(len_snd);
				sndbuf[3] = HIBYTE(len_snd);
				sndbuf[4] = sndbuf[5] = 0x03;
				sndbuf[6] = LOBYTE(n_event);
				sndbuf[7] = HIBYTE(n_event);
				for (i = 0; i < n_event; i++)
				{
					sndbuf[8 + 4 * i] = LOBYTE(confirm_events[i].fault_no);
					sndbuf[8 + 4 * i + 1] = HIBYTE(confirm_events[i].fault_no);
					sndbuf[8 + 4 * i + 2] = LOBYTE(confirm_events[i].info_no);
					sndbuf[8 + 4 * i + 3] = HIBYTE(confirm_events[i].info_no);
				}
				sndbuf[len_snd - 2] = sndbuf[len_snd - 1] = 0x86;
				free(confirm_events);
				//if (send(ConnectSocket, sndbuf, len_snd, 0) == SOCKET_ERROR)
				{
					// do nothing
				}
			}

			Sleep(100);
		}

		Sleep(10);
	}

	if (ConnectSocket != SOCKET_ERROR)
		closesocket(ConnectSocket);

	sprintf(infostr, "#%d线程结束", station);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, -1);
	dec_var(Count_FER);

	return 0L;
}