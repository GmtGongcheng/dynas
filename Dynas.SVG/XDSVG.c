#include <windows.h>
#include <winsock.h>
//#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
//#include <dir.h>
#include "rule_log.h"
#include "pansi.h"    // header file generated by MIDL compiler
#include "panserver2.h"

enum TYPE_TEL
{
	YTVAL_BACK = 0x0202,  //返回当前定值
	YTWRITE_STAUS = 0x0204,  //写定值操作结果
	YT_YC_TEL = 0x0303,  //遥信遥测报文
	SOE_TEL = 0x0404   //事件报文

};

int DEBUG_LOG = 1;

#define BUFLEN 2500

char checkFrameFlag(unsigned char* srcBuf, int iCurrPos)
{
#define I870DEF4_APDU_START_CHARACTER 0x68
	if (srcBuf[iCurrPos] == I870DEF4_APDU_START_CHARACTER) //判断首字符是否等于0x68
	{
		return 1;
	}
	else
		return 0;
}

int getOneFrame(unsigned char* srcBuf, int iSrcLen, unsigned char*oneframeBuf, int  iOneframe_Len)
{
	//缓冲区不够完整一帧，返回0
	//确定完整一帧，返回1
	int iRet = 0;//返回值
	int iLeftLen = 0;//缓冲区剩余报文长度
	//最小报文帧长度
#define MIN_FRAME_LEN 6

	iLeftLen = iSrcLen;

	int iCurrPos = 0;//输出缓冲区当前位置标记

	//退出循环标记:（1）确定完整一帧，或（2）剩余长度小于最小帧长，或（3）剩余长度小于“报文长度字节”表示的长度，即可退出循环
	char bExit = 0;
	while (!bExit)
	{
		if (iLeftLen < MIN_FRAME_LEN)//小于最小帧长时，退出循环
		{
			iRet = 0;
			bExit = 1;//退出循环
		}
		else
		{
			if (checkFrameFlag(srcBuf, iCurrPos) == 0)
			{
				//首字符不等于0x68，需要记录输出信息
				iCurrPos++;
				iLeftLen = iSrcLen - iCurrPos;
				continue;
			}
			else if (checkFrameFlag(srcBuf, iCurrPos) == 1) //判断首字符是否等于0x68
			{
				//判断长度
				unsigned char iFrameLen = 0;
				iFrameLen = srcBuf[iCurrPos + 2] + 256 * srcBuf[iCurrPos + 3];
				//是否够完整一帧
				if (iLeftLen >= iFrameLen)
				{
					memcpy(oneframeBuf, &srcBuf[iCurrPos], iFrameLen); //取出一完整帧

					//printOneFrame(oneframeBuf, iFrameLen);
					iOneframe_Len = iFrameLen;//帧长

					iLeftLen = iSrcLen - iCurrPos - iFrameLen;//计算剩余长度，以便退出循环

					iCurrPos += iFrameLen;//当前位置移动

					iRet = 1;//确定完整一帧
					bExit = 1;//退出循环
				}
				else//剩余长度已经不够完整一帧
				{
					iRet = 0;//剩余长度已经不够
					bExit = 1;//退出循环
				}

			}//end else if 
		}//end else 

	}//end while


	return iRet;

}

//static int com_operation(SOCKET sock, long vid, float fv)
static int com_operation(SOCKET sock, int station, int point, int vtype, float fv)
{
	unsigned char sndbuf[BUFLEN];
	unsigned short len_snd;

	//int station = GetVarStation(vid);
	//int point = GetVarPoint(vid);
	//int vtype = GetVarType(vid);

	//if (vid == 0)
	//	return -1;

	memset(sndbuf, 0, BUFLEN);

	sndbuf[0] = sndbuf[1] = 0x68;

	if (vtype == VARTYPE_YX)
	{
		//if (point == pStation[station].yt_read)
		//{
		//	len_snd = 14;
		//	sndbuf[2] = LOBYTE(len_snd);
		//	sndbuf[3] = HIBYTE(len_snd);
		//	sndbuf[4] = 0x02;
		//	sndbuf[5] = 0x01;
		//	sndbuf[6] = sndbuf[7] = 0xFF;

		//	sndbuf[12] = sndbuf[13] = 0x86;

		//} 
		//else
		//{
			len_snd = 15;
			sndbuf[2] = LOBYTE(len_snd);
			sndbuf[3] = HIBYTE(len_snd);
			sndbuf[4] = sndbuf[5] = 0x01;
			sndbuf[6] = (point - pStation[station].yk_begin) / 16;
			sndbuf[7] = (point - pStation[station].yk_begin) % 16;
			sndbuf[8] = fv ? 1 : 0;

			sndbuf[13] = sndbuf[14] = 0x86;

		//}
	}
	else
	{
		int num_yk = pStation[station].yt_end - pStation[station].yt_begin + 1;
		int i;
		char infostr[256];

		len_snd = 4 * num_yk + 14;
		sndbuf[2] = LOBYTE(len_snd);
		sndbuf[3] = HIBYTE(len_snd);
		sndbuf[4] = 0x02;
		sndbuf[5] = 0x02;
		sndbuf[6] = LOBYTE(num_yk);
		sndbuf[7] = HIBYTE(num_yk);
		for (i = 0; i < num_yk; i++)
		{
			union {
				float f;
				char c[4];
			} v;
			if (point == pStation[station].yt_begin + i)
				v.f = fv;
			else
				v.f = ppYC[station][pStation[station].yt_begin + i].yc.value;

			sndbuf[8 + 4 * i] = v.c[0];
			sndbuf[8 + 4 * i + 1] = v.c[1];
			sndbuf[8 + 4 * i + 2] = v.c[2];
			sndbuf[8 + 4 * i + 3] = v.c[3];
		}
		sndbuf[4 * num_yk + 12] = sndbuf[4 * num_yk + 13] = 0x86;

		sprintf(infostr, "YT (%d, %d)\n", num_yk, point);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
	}

	if (send(sock, sndbuf, len_snd, 0) == SOCKET_ERROR)
	{
		//sprintf(infostr, "Opearation send failed. Error#%d\n", WSAGetLastError());
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		//set_var(VarID_OPER, 0);
		return -1;
	}
	if (DEBUG_LOG == 1)
	{
		WriteLog_Tele(station, sndbuf, len_snd, 0,rulestr);
	}
	//recv(sock, sndbuf, BUFLEN, 0);

	return 0;
}


int WINAPI Routine_XD_SVG(int station)
{
	ppYX[station][0].yx.value = 0;
	SOCKET ConnectSocket;	// = INVALID_SOCKET;
	//struct addrinfo *result = NULL, hints;
	struct sockaddr_in addr;
	// 	struct timeval timeout;
	int iResult;
	char *ipstr;

	char infostr[240];
	char datafile[256];

	if (pStation[station].addr1[0] == 0 && pStation[station].addr2[0] == 0 && pStation[station].port == 0)
	{
		sprintf(infostr, "station(%d): 地址错误 (%s, %s, %d)\n", station,
			pStation[station].addr1, pStation[station].addr2, pStation[station].port);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
		return -1;
	}

	ipstr = pStation[station].addr2[0] ? pStation[station].addr2 : pStation[station].addr1;


	sprintf(datafile, ".\\facdata\\Lastvalues_%d.dat", station);

	sprintf(infostr, "\r\n#%d线程启动\r\n", station);
	WriteLog(station, rulestr, infostr);


	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, 1);	
	inc_var(Count_FER);
	while (get_var(Flag_FER))
	{
		int fComStateChange;
		int new_soe_inf, new_alarm_inf, new_ind_inf;
		new_soe_inf = 0;
		new_alarm_inf = 0;
		new_ind_inf = 0;

		pStation[station].oper_point = 0;  //set_var(VarID_OPER, 0);
		fComStateChange = 0;

		// Connect to server.
		// Create a SOCKET for connecting to server
		ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (ConnectSocket == INVALID_SOCKET) {
			sprintf(infostr, "station(%d): socket failed (%ld)", station, WSAGetLastError());
			//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			DebugPrintln(infostr);
			return -1;
		}

		// 设置连接超时时间
		//linux下
		// 		timeout.tv_sec = 5;
		// 		timeout.tv_usec = 0;
		// 		setsockopt(ConnectSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));
		// 		setsockopt(ConnectSocket, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout));

		//windows下
		int timeout = 5000; //5s
		setsockopt(ConnectSocket, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
		setsockopt(ConnectSocket, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));


		addr.sin_family = AF_INET;
		addr.sin_port = htons(pStation[station].port);

		if (ipstr == pStation[station].addr1)
		{
			if (pStation[station].addr2[0])
				ipstr == pStation[station].addr2;
		}
		else
		{
			if (pStation[station].addr1[0])
				ipstr == pStation[station].addr1;
		}
		addr.sin_addr.s_addr = inet_addr(ipstr);

		//sprintf(infostr, "#%d连接:%s", station, ipstr);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);

		iResult = connect(ConnectSocket, (SOCKADDR*)&addr, sizeof(addr));
		if (iResult == SOCKET_ERROR) // 通道连接失败
		{
			closesocket(ConnectSocket);
			ConnectSocket = SOCKET_ERROR;

			if (ppYX[station][0].yx.value == 1)
			{
				//FILE *fp;

				SYSTEMTIME	systime;
				memset(&systime, 0x00, sizeof(systime));
				GetCurTime(&systime);

				waitfor_mutex(Mutex_RT);

				ppYX[station][0].yx.value = 0;

				release_mutex(Mutex_RT);

				sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d #%d站连接中断!", systime.wYear, systime.wMonth, systime.wDay,
					systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds, station);

				WriteLog(station, rulestr, "\r\n连接中断!\r\n");

				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
			}

			Sleep(100);
			continue;
		}
		else	// 通道连接成功
		{
			SYSTEMTIME	systime;
			memset(&systime, 0x00, sizeof(systime));
			GetCurTime(&systime);
			sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d #%d站连接成功!", systime.wYear, systime.wMonth, systime.wDay,
				systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds, station);
			DebugPrintln(infostr);
				WriteLog(station, rulestr, "\r\n连接成功!\r\n");
			waitfor_mutex(Mutex_RT);
			if (ppYX[station][0].yx.value == 0)
			{
				fComStateChange = 1;
				ppYX[station][0].yx.value = 1;
			}
			release_mutex(Mutex_RT);
		}

		while (get_var(Flag_FER))
		{
			unsigned char sndbuf[BUFLEN];
			unsigned char rcvbuf[BUFLEN];
			memset(sndbuf, 0, BUFLEN * sizeof(char));
			memset(rcvbuf, 0, BUFLEN * sizeof(char));
			int len_snd, len_rcv;
			unsigned int n_yx, n_yc, n_event, n_yt, n_Ind, n_Alarm, n_SOE;
			unsigned int yx_offset, yc_offset, event_offset, Ind_offset, Alarm_offset, SOE_offset;
			unsigned int end_offset;
			unsigned int tel_type, operate_status;

			union {
				float f;
				char c[4];
			} fv;

			int vid_oper;

			struct EVENTNO {
				unsigned short fault_no;
				unsigned short info_no;
			} *confirm_events;

			/*
			vid_oper = get_var(VarID_OPER);
			if (0)		//vid_oper)
			{
			sprintf(infostr, "Station %d, YK：%04X", GetVarStation(vid_oper), pStation[station].oper_value);	//Var_OPER);
			SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			}
			*/
			//if (vid_oper && GetVarStation(vid_oper) == station)
			if (pStation[station].oper_point > 0)
			{
				int point = pStation[station].oper_point;	//GetVarPoint(vid_oper);
				int vtype = pStation[station].oper_type;	//GetVarType(vid_oper);

				sprintf(infostr, "\r\n控制操作：%s (%d, %d) = %.2f", vtype == VARTYPE_YC ? "遥调" : "遥控", station, point, pStation[station].oper_value);	//Var_OPER);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
				strcat(infostr, "\r\n");
				WriteLog(station, rulestr, infostr);
				//com_operation(ConnectSocket, vid_oper, Var_OPER);
				com_operation(ConnectSocket, station, point, vtype, pStation[station].oper_value);	//Var_OPER);

				pStation[station].oper_point = 0;  //set_var(VarID_OPER, 0);
			}

			if (fComStateChange)
			{
				fComStateChange = 0;

				// 【连接成功后代码在此】。。。
			}

			iResult = recv(ConnectSocket, rcvbuf, BUFLEN, 0);
			if (iResult == SOCKET_ERROR)
			{
				SYSTEMTIME	systime;
				memset(&systime, 0x00, sizeof(systime));
				GetCurTime(&systime);
				sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d %d站recv()返回 SOCKET_ERROR，Error:%d", systime.wYear, systime.wMonth, systime.wDay,
					systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds,station, WSAGetLastError());
				DebugPrintln(infostr);
				if (DEBUG_LOG == 1)
				{
					WriteLog(station, rulestr,"\r\nSOCKET_ERROR recv()返回 SOCKET_ERROR\r\n");
				}

				ppYX[station][0].yx.value = 0;
				closesocket(ConnectSocket);
				Sleep(2000);
				break;
			}


			len_rcv = iResult;
			if (len_rcv == 0)
			{
				SYSTEMTIME	systime;
				memset(&systime, 0x00, sizeof(systime));
				GetCurTime(&systime);
				sprintf(infostr, "%04d-%02d-%02d %02d:%02d:%02d %03d %d站对端关闭连接，recv()返回 %d, WSAGetLastError() = %d", systime.wYear, systime.wMonth, systime.wDay,
					systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds, station, len_rcv, WSAGetLastError());
				DebugPrintln(infostr);
				if (DEBUG_LOG == 1)
				{
					WriteLog(station, rulestr,"\r\n对端关闭连接，recv()返回0\r\n");
				}

				ppYX[station][0].yx.value = 0;
				closesocket(ConnectSocket);
				Sleep(2000);
				break;
			}
			if (DEBUG_LOG == 1)
			{
				WriteLog_Tele(station, rcvbuf, len_rcv, 1,rulestr);
			}

			//printf("len_rcv = %d ", len_rcv);
			//for (int i = 0; i < len_rcv; i++)
			//{
			//	printf("%02x ", rcvbuf[i]);
			//}
			//printf("\n");


			end_offset = len_rcv - 6;
			tel_type = rcvbuf[4] + 256 * rcvbuf[5];
			switch (tel_type)
			{
			case YT_YC_TEL:                  //0x0303正常的遥信遥测报文

				yx_offset = rcvbuf[6] + 256 * rcvbuf[7];
				yc_offset = rcvbuf[8] + 256 * rcvbuf[9];
				if (yc_offset && (yc_offset < end_offset))
				{
					n_yc = (end_offset - yc_offset) / 4;
					end_offset = yc_offset;
				}
				else
				{
					sprintf(infostr, "%d站遥信遥测数组越界！！！\r\n", station);
					DebugPrintln(infostr);
					WriteLog(station, rulestr, infostr);
					break;
				}
				if (yx_offset)
				{
					n_yx = (end_offset - yx_offset) * 16;
					end_offset = yx_offset;
				}

				waitfor_mutex(Mutex_RT);

				for (int i = 0; i < n_yx; i++)
				{
					unsigned short c;
					short new_value;

					if (i >= System.nYX - 1)
						break;

					c = rcvbuf[yx_offset + 2 * (i / 16)] + 256 * rcvbuf[yx_offset + 2 * (i / 16) + 1];
					//new_value = (c<<(i%16)) & 0x8000U ? 1 : 0;
					new_value = (c >> (i % 16)) & 0x0001U ? 1 : 0;

					if (new_value == ppYX[station][i + 1].yx.value)
						continue;
					ppYX[station][i + 1].yx.value = new_value;
				}
				for (int i = 0; i < n_yc; i++)
				{
					if (i >= System.nYC - 1)
						break;
					fv.c[0] = rcvbuf[yc_offset + 4 * i];
					fv.c[1] = rcvbuf[yc_offset + 4 * i + 1];
					fv.c[2] = rcvbuf[yc_offset + 4 * i + 2];
					fv.c[3] = rcvbuf[yc_offset + 4 * i + 3];
					ppYC[station][i + 1].yc.value = fv.f;
				}

				release_mutex(Mutex_RT);
				break;

			case SOE_TEL:  //0x0404   //事件报文
				Ind_offset = rcvbuf[6] + 256 * rcvbuf[7];
				Alarm_offset = rcvbuf[8] + 256 * rcvbuf[9];
				SOE_offset = rcvbuf[10] + 256 * rcvbuf[11];

				n_Ind = rcvbuf[12];  //ind事件个数
				n_Alarm = rcvbuf[13];  //alarm事件个数
				n_SOE = rcvbuf[14]; //SOE事件个数

				//SOE
				for (int i = 0; i < n_SOE; i++)
				{
					struct SOE_DATA {
						unsigned int Order;  //序号
						unsigned char TYP;   //类型标识 值为70
						unsigned char NUM;   //模拟量数量，为1表示无模拟量 num-1
						unsigned char COT;   //固定为1，表示突变上送
						unsigned char ADDR;  //公共地址:CPU号(ADDR)
						unsigned char FUNC;  // 功能类型(FUN)) 1~3,表示SVG产品
						unsigned char INF;   //信息序号(INF)
						unsigned char ST;    //事件状态(ST1)
						unsigned int msL;    //相对时间
						unsigned short FANL;  //电网故障序号
						unsigned short msH;   //绝对时间MS
						unsigned char min;   //绝对时间分钟
						unsigned char hour;  //绝对时间小时
						unsigned char day;   //绝对时间日期
						unsigned char mon;   //绝对时间月份
						unsigned char year;  //绝对时间年
						unsigned char SIN;   //SIN 固定为0
						unsigned char FLTTYP;// 故障类型(FLTTYP)
					} SOE_data;
					if (SOE_offset + 26 > len_rcv)
					{
						sprintf(infostr, "%d站SOE数组越界！！！\r\n", station);
						DebugPrintln(infostr);
						WriteLog(station, rulestr, infostr);
						break;
					}
					memcpy(&SOE_data, rcvbuf + SOE_offset, 26);
					int num_fv;
					int inf;
					char fauVal[128];
					memset(fauVal, 0, 128 * sizeof(char));
					int ytvalue[100];
					num_fv = SOE_data.NUM - 1;
					inf = SOE_data.INF;
					char soe_log[1024];
					memset(soe_log, 0, 1024 * sizeof(char));

					sprintf(soe_log, "%d,%d-%d-%d %d:%d:%d,%s,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,", SOE_data.Order, SOE_data.year, SOE_data.mon, SOE_data.day, SOE_data.hour,
						SOE_data.min, SOE_data.msH, ppSOE[station][inf].name, SOE_data.INF, SOE_data.TYP, SOE_data.NUM - 1, SOE_data.COT, SOE_data.ADDR, SOE_data.FUNC, SOE_data.ST, SOE_data.msL,
						SOE_data.FANL, SOE_data.SIN, SOE_data.FLTTYP);

					memcpy(ytvalue, ppSOE[station][inf].yt_value, 100);
					SOE_offset += 26;
					for (int i = 0; i < num_fv; i++)
					{
						union {
							float f;
							char c[4];
						} fv;
						fv.c[0] = rcvbuf[SOE_offset + 4 * i];
						fv.c[1] = rcvbuf[SOE_offset + 4 * i + 1];
						fv.c[2] = rcvbuf[SOE_offset + 4 * i + 2];
						fv.c[3] = rcvbuf[SOE_offset + 4 * i + 3];
						ppYC[station][ytvalue[i]].yc.value = fv.f;
						sprintf(fauVal, "%s %s=%.2f ", fauVal, ppYC[station][ytvalue[i]].name, fv.f);
					}
					SOE_offset += num_fv * 4;
					strcat(soe_log, fauVal);
					sprintf(soe_log, "%s\n", soe_log);
					WriteSOE(station, soe_log, rulestr, "soe");
					new_soe_inf = SOE_data.Order;
				}

				//Alarm
				for (int i = 0; i < n_Alarm; i++)
				{
					struct SOE_DATA {
						unsigned int Order;  //序号
						unsigned char TYP;   //类型标识 值为70
						unsigned char COT;   //固定为1，表示突变上送
						unsigned char ADDR;  //公共地址:CPU号(ADDR)
						unsigned char FUNC;  // 功能类型(FUN)) 1~3,表示SVG产品
						unsigned char INF;   //信息序号(INF)
						unsigned char ST;    //事件状态(ST1)
						unsigned short msH;   //绝对时间MS
						unsigned char min;   //绝对时间分钟
						unsigned char hour;  //绝对时间小时
						unsigned char day;   //绝对时间日期
						unsigned char mon;   //绝对时间月份
						unsigned char year;  //绝对时间年
						unsigned char SIN;   //SIN 固定为0
					} SOE_data;
					if (Alarm_offset + 18 > len_rcv)
					{
						sprintf(infostr, "%d站Alarm数组越界！！！\r\n", station);
						DebugPrintln(infostr);
						WriteLog(station, rulestr, infostr);
						break;
					}
					memcpy(&SOE_data, rcvbuf + Alarm_offset, 18);
					int inf = SOE_data.INF;
					char soe_log[512];
					sprintf(soe_log, "%d,%d-%d-%d %d:%d:%d,%s,%d,%d,%d,%d,%d,%d,%d\n", SOE_data.Order, SOE_data.year, SOE_data.mon, SOE_data.day, SOE_data.hour,
						SOE_data.min, SOE_data.msH, ppAlarm[station][inf].name, SOE_data.INF, SOE_data.TYP, SOE_data.COT, SOE_data.ADDR, SOE_data.FUNC, SOE_data.ST, SOE_data.SIN);
					WriteSOE(station, soe_log, rulestr, "alarm");
					Alarm_offset += 18;
					new_alarm_inf = SOE_data.Order;
				}

				//Ind
				for (int i = 0; i < n_Ind; i++)
				{
					struct SOE_DATA {
						unsigned int Order;  //序号
						unsigned char TYP;   //类型标识 值为70
						unsigned char COT;   //固定为1，表示突变上送
						unsigned char ADDR;  //公共地址:CPU号(ADDR)
						unsigned char FUNC;  // 功能类型(FUN)) 1~3,表示SVG产品
						unsigned char INF;   //信息序号(INF)
						unsigned char ST;    //事件状态(ST1)
						unsigned short msH;   //绝对时间MS
						unsigned char min;   //绝对时间分钟
						unsigned char hour;  //绝对时间小时
						unsigned char day;   //绝对时间日期
						unsigned char mon;   //绝对时间月份
						unsigned char year;  //绝对时间年
						unsigned char SIN;   //SIN 固定为0
					} SOE_data;
					if (Ind_offset + 18 > len_rcv)
					{
						sprintf(infostr, "%d站Ind数组越界！！！\r\n",station);
						DebugPrintln(infostr);
						WriteLog(station, rulestr, infostr);
						break;
					}
					memcpy(&SOE_data, rcvbuf + Ind_offset, 18);
					int inf = SOE_data.INF;
					char soe_log[512];
					sprintf(soe_log, "%d,%d-%d-%d %d:%d:%d,%s,%d,%d,%d,%d,%d,%d,%d\n", SOE_data.Order, SOE_data.year, SOE_data.mon, SOE_data.day, SOE_data.hour,
						SOE_data.min, SOE_data.msH, ppInd[station][inf].name, SOE_data.INF, SOE_data.TYP, SOE_data.COT, SOE_data.ADDR, SOE_data.FUNC, SOE_data.ST, SOE_data.SIN);
					WriteSOE(station, soe_log, rulestr, "Ind");
					Ind_offset += 18;
					new_ind_inf = SOE_data.Order;
				}

				//事件回复
				union {
					int nNum;
					char soe_buf[4];
				}soeback;
				len_snd = 27;
				memset(sndbuf, 0, len_snd);
				sndbuf[0] = sndbuf[1] = 0x68;
				sndbuf[2] = LOBYTE(len_snd);
				sndbuf[3] = HIBYTE(len_snd);
				sndbuf[4] = 0x05;
				sndbuf[5] = 0x04;
				sndbuf[6] = n_Ind;
				sndbuf[7] = n_Alarm;
				sndbuf[8] = n_SOE;

				soeback.nNum = new_ind_inf;
				sndbuf[9] = soeback.soe_buf[0];
				sndbuf[10] = soeback.soe_buf[1];
				sndbuf[11] = soeback.soe_buf[2];
				sndbuf[12] = soeback.soe_buf[3];

				soeback.nNum = new_alarm_inf;
				sndbuf[13] = soeback.soe_buf[0];
				sndbuf[14] = soeback.soe_buf[1];
				sndbuf[15] = soeback.soe_buf[2];
				sndbuf[16] = soeback.soe_buf[3];

				soeback.nNum = new_soe_inf;
				sndbuf[17] = soeback.soe_buf[0];
				sndbuf[18] = soeback.soe_buf[1];
				sndbuf[19] = soeback.soe_buf[2];
				sndbuf[20] = soeback.soe_buf[3];
				sndbuf[len_snd - 2] = sndbuf[len_snd - 1] = 0x86;
				if (send(ConnectSocket, sndbuf, len_snd, 0) == SOCKET_ERROR)
				{
					if (DEBUG_LOG == 1)
					{
						WriteLog(station, rulestr, "回复报文失败\r\n");
					}
				}
				if (DEBUG_LOG == 1)
				{
					WriteLog_Tele(station, sndbuf, len_snd, 0, rulestr);
				}
				break;
			default:
				printf("未识别的报文类型tel_type = %04x", tel_type);
				break;
			}
			Sleep(100);
		}

		Sleep(10);
	}

	if (ConnectSocket != SOCKET_ERROR)
		closesocket(ConnectSocket);

	sprintf(infostr, "#%d线程结束", station);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, -1);
	dec_var(Count_FER);

	return 0L;
}