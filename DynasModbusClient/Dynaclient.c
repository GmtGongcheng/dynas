#include <WinSock2.h>
#include <Windows.h>
#include <stdio.h>
#include <stdint.h>
#include "pansi.h"    // header file generated by MIDL compiler
#include "panserver2.h"
#include "Dynaclient.h"
#include "modbus.h"

#define SERVER_ID 1

modbus_mapping_t * mb_mapping;
Modbus_SYSTEM System;
extern BOOL connectA;
Modbus_YC *ppModYC = NULL;
Modbus_YX *ppModYX = NULL;
Modbus_YK *ppModYK = NULL;
Modbus_YT *ppModYT = NULL;
unsigned __stdcall NetSetupThread(LPVOID lp);
//LRESULT WINAPI WriteYC_YX()
unsigned __stdcall WriteYC_YX()
{
	long yx_pids[2048];
	long yc_pids[2048];
	PS_rt_yx __RPC_FAR yx_data[2048];
	PS_rt_yc __RPC_FAR yc_data[2048];
	while (1)
	{
		if (connectA)
		{
			__try
			{
				for (int i = 0; i < System.nYX; i++)
				{
					yx_pids[i] = MergeVarID(VARTYPE_YX, ppModYX[i + 1].station, ppModYX[i + 1].point, 0);  //遥信
				}
				RPC_GetRealtimeYXData(yx_pids, yx_data, System.nYX);
				for (int i = 0; i < System.nYC; i++)
				{
					yc_pids[i] = MergeVarID(VARTYPE_YC, ppModYC[i + 1].station, ppModYC[i + 1].point, 0);  //遥信
				}
				RPC_GetRealtimeYXData(yc_pids, yc_data, System.nYC);
				for (int i = 0; i < System.nYX; i++)
				{
					mb_mapping->tab_input_registers[i / 16] &= yx_data[i].value << (i % 16);
				}
				for (int i = 0; i < System.nYC; i++)
				{
					mb_mapping->tab_registers[i] = (uint16_t)(yc_data[i].value * ppModYC[i + 1].k + 0.5);
				}
			}
			__except (1)
			{
				DebugPrintln("fail to receive datas!");
			}
			Sleep(200);
		}
		else
		{
			Sleep(200);
			continue;
		}
	}
	return 0L;
}

int main()
{
	if (FrontEndSetup() < 0)
	{
		DebugPrintln("FrontEnd Setup Failure.");
		exit(-1);
	}
	DebugPrintln("FrontEnd Setup OK.");
	HANDLE hThread[2] = { 0 };
	unsigned threadid[2] = { 0 };

	//DWORD id,id1;
	//CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)NetSetupThread, 0, 0, &id);
	//CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WriteYC_YX, 0, 0, &id1);
	hThread[0] = (HANDLE)_beginthreadex(NULL, 0, NetSetupThread, 0, 0, &threadid[0]);
	hThread[1] = (HANDLE)_beginthreadex(NULL, 0, WriteYC_YX, 0, 0, &threadid[1]);
	long yk_varid;
	long yt_varid;
	modbus_t * ctx;

	ctx = modbus_new_rtu("COM4", 9200, 'N', 8, 1);
	modbus_set_slave(ctx, SERVER_ID);

	if (modbus_connect(ctx,SERVER_ID) == -1)
	{
		fprintf(stderr, "Connection failed:%s\n", modbus_strerror(errno));
		modbus_free(ctx);
		//return - 1;
	}
	modbus_set_debug(ctx, TRUE);

	int slaveAddr = 1;
	int debug = 0;
	int diNo = 100;    //离散输入寄存器的个数
	int coilsNo = 100; //设置线圈寄存器的个数
	int irNo = 100;    //设置输入寄存器的个数
	int hrNo = 100;    //设置保持寄存器的个数
	//创建寄存器内存块
	mb_mapping = modbus_mapping_new_start_address(0, coilsNo, 0, diNo,0, hrNo,0, irNo);
	if (mb_mapping == NULL)
	{
		fprintf(stderr, "Failed to allocate the mapping: %s\n",
			modbus_strerror(errno));
		exit(EXIT_FAILURE);
	}

	//循环接收查询帧并回复消息
	while (1)
	{
		uint8_t query[MODBUS_TCP_MAX_ADU_LENGTH];
		int rc;

		rc = modbus_receive(ctx, query);
		if (rc >= 0)
		{
			/*rc is the query size*/
			modbus_reply(ctx, query, rc, mb_mapping);  //回复响应报文
			int function = query[1];
			uint16_t address;
			address = (query[2] << 8) + query[3];
			switch (function) {
			case MODBUS_FC_WRITE_SINGLE_COIL: {
				for (int i = 0; i < System.nYK; i++)
				{
					if (address == ppModYK[i].addr)
					{
						long yk_varid = MergeVarID(VARTYPE_YX, ppModYK[i].station, ppModYK[i].point, 0);
						RPC_YKRequest(yk_varid, 1, "nothing");
						RPC_YKExecute(yk_varid, 1, "nothing");
					}
				}
			}
			break;
			case MODBUS_FC_WRITE_SINGLE_REGISTER: {
				for (int i = 0; i < System.nYT; i++)
				{
					if (address == ppModYT[i].addr)
					{
						int data = (query[4] << 8) + query[5];
						float yt_value = (float)(data * ppModYT[i].k);
						long yt_varid = MergeVarID(VARTYPE_YX, ppModYT[i].station, ppModYT[i].point, 0);
						RPC_YKRequest(VARTYPE_YC, data, "nothing");
						RPC_YKExecute(VARTYPE_YC, data, "nothing");
					}
				}
			}

			break;

			default:
				break;

			}
		}
		else
		{
			//Connection closed by the client or error
			DebugPrintln("Connect Close!");
		}
		Sleep(200);
	}
	DebugPrintln("Quit the loop: %s\n", modbus_strerror(errno));

	//释放内存
	modbus_mapping_free(mb_mapping);
	modbus_close(ctx);
	modbus_free(ctx);

	FrontEndCleanup(0);
	return 0;
}