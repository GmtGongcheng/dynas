#include <windows.h>
#include <winsock.h>
//#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
//#include <dir.h>

#include "pansi.h"    // header file generated by MIDL compiler
#include "panserver2.h"

#define BUFLEN 2048
//int fRun = -1; // 1: routine running; 0: routine stopping; -1: routine stopped

//static int com_operation(SOCKET sock, long vid, int value)
static int com_operation(SOCKET sock, int point, int vtype, int value)
{
	unsigned char sndbuf[BUFLEN];
	int len_snd;

	//int point = GetVarPoint(vid);
	//int vtype = GetVarType(vid);

	//if (vid == 0)
	//	return -1;

	memset(sndbuf, 0, BUFLEN);
	len_snd = 22;
	sndbuf[0] = sndbuf[1] = 0x68;
	sndbuf[5] = vtype == VARTYPE_YC ? 1 : 11;
	sndbuf[14] = HIBYTE(point);		sndbuf[15] = LOBYTE(point);
	sndbuf[18] = HIBYTE(value);	sndbuf[19] = LOBYTE(value);
	sndbuf[20] = sndbuf[21] = 0x86;

	if (send(sock, sndbuf, len_snd, 0) == SOCKET_ERROR)
	{
		//sprintf(infostr, "Opearation send failed. Error#%d\n", WSAGetLastError());
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		//set_var(VarID_OPER, 0);
		return -1;
	}

	recv(sock, sndbuf, BUFLEN, 0);

	return 0;
}

int WINAPI Routine_XD_FK(int station)
{
	SOCKET ConnectSocket;	// = INVALID_SOCKET;
	//struct addrinfo *result = NULL, hints;
	struct sockaddr_in addr;
	struct timeval timeout;
	int iResult;
	char *ipstr;

	char infostr[240];
	char datafile[256];

	if (pStation[station].addr1[0] == 0 && pStation[station].addr2[0] == 0 && pStation[station].port == 0)
	{
		sprintf(infostr, "station(%d): 地址错误 (%s, %s, %d)\n", station, 
			pStation[station].addr1, pStation[station].addr2, pStation[station].port);
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
		return -1;
	}	
	
	// Create a SOCKET for connecting to server
	ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (ConnectSocket == INVALID_SOCKET) {
		sprintf(infostr, "station(%d): socket failed (%ld)\n", station, WSAGetLastError());
		//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
		DebugPrintln(infostr);
		return -1;
	}

	// 设置连接超时时间
	timeout.tv_sec = 5;
	timeout.tv_usec = 0;
	setsockopt(ConnectSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));
	setsockopt(ConnectSocket, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout));

	addr.sin_family = AF_INET;
	addr.sin_port = htons(pStation[station].port);
	ipstr = pStation[station].addr2[0] ? pStation[station].addr2 : pStation[station].addr1;

	sprintf(datafile, ".\\facdata\\Lastvalues_%d.dat", station);

	sprintf(infostr, "#%d线程启动", station);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, 1);	
	inc_var(Count_FER);
	while (get_var(Flag_FER))
	{
		int fComStateChange;

		pStation[station].oper_point = 0;	//set_var(VarID_OPER, 0);
		fComStateChange = 0;

		// Connect to server.
		if (ipstr == pStation[station].addr1)
		{
			if (pStation[station].addr2[0])
				ipstr == pStation[station].addr2;
		}
		else
		{
			if (pStation[station].addr1[0])
				ipstr == pStation[station].addr1;
		}
		addr.sin_addr.s_addr = inet_addr(ipstr);

		iResult = connect(ConnectSocket, (SOCKADDR*)&addr, sizeof(addr));
		if (iResult == SOCKET_ERROR) // 通道连接失败
		{
			waitfor_mutex(Mutex_RT);
			if (ppYX[station][0].yx.value == 1)
			{
				FILE *fp;
				// Save Last point vlue
				fp = fopen(datafile, "wb");
				if (fp)
				{
					int i;
					for (i = 1; i < System.nYX; i++)
					{
						short sv = ppYX[station][i].yx.value;
						fwrite(&sv, sizeof(short), 1, fp);
					}
					for (i = 1; i < System.nYC; i++)
					{
						float fv = ppYC[station][i].yc.value;
						fwrite(&fv, sizeof(float), 1, fp);
					}
					fclose(fp);
				}

				ppYX[station][0].yx.value = 0;

				sprintf(infostr, "#%d站连接中断!", station);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);
			}
			release_mutex(Mutex_RT);

			Sleep(100);
			continue;
		}
		else	// 通道连接成功
		{
			sprintf(infostr, "#%d站连接成功!", station);
			//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
			DebugPrintln(infostr);

			waitfor_mutex(Mutex_RT);
			if (ppYX[station][0].yx.value == 0)
			{
				fComStateChange = 1;
				ppYX[station][0].yx.value = 1;
			}
			release_mutex(Mutex_RT);
		}

		while (get_var(Flag_FER))
		{
			unsigned char sndbuf[BUFLEN];
			unsigned char rcvbuf[BUFLEN];
			int len_snd, len_rcv;
			int n_yx, n_yc, yxstart;
			int i;

			/*
			int vid_oper;

			vid_oper = pStation[station].oper_point;	//get_var(VarID_OPER);
			if (vid_oper && GetVarStation(vid_oper) == station)
			*/
			if (pStation[station].oper_point > 0)
			{
				int point = pStation[station].oper_point;	//GetVarPoint(vid_oper);
				int vtype = pStation[station].oper_type;	//GetVarType(vid_oper);

				sprintf(infostr, "控制操作：%s (%d, %d) = %.2f", vtype == VARTYPE_YC ? "遥调" : "遥控", station, point, pStation[station].oper_value); //Var_OPER);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);

				//com_operation(ConnectSocket, vid_oper, (int)pStation[station].oper_value);	//(int)Var_OPER);
				com_operation(ConnectSocket, point, vtype, (int)pStation[station].oper_value);

				pStation[station].oper_point = 0;	//set_var(VarID_OPER, 0);
			}

			if (fComStateChange)
			{
				fComStateChange = 0;

				if (access(datafile, 0) == 0)
				{
					int yk1, yk2, yt1, yt2;

					yk1 = pStation[station].yk_begin;
					yk2 = pStation[station].yk_end;
					yt1 = pStation[station].yt_begin;
					yt2 = pStation[station].yt_end;

					for (i = yk1; i <= yk2; i++)
					{
						waitfor_mutex(Mutex_RT);
						//com_operation(ConnectSocket, MergeVarID(VARTYPE_YX, station, i, 0), (int)ppYX[station][i].yx.value);
						com_operation(ConnectSocket, i, VARTYPE_YX, (int)ppYX[station][i].yx.value);
						release_mutex(Mutex_RT);
					}

					for (i = yt1; i <= yt2; i++)
					{
						waitfor_mutex(Mutex_RT);
						//com_operation(ConnectSocket, MergeVarID(VARTYPE_YC, station, i, 0), (int)ppYC[station][i].yc.value);
						com_operation(ConnectSocket, i, VARTYPE_YC, (int)ppYC[station][i].yc.value);
						release_mutex(Mutex_RT);
					}
				}
			}

			// Send ALL CALL datagram
			memset(sndbuf, 0, BUFLEN);

			len_snd = 22;
			sndbuf[0] = sndbuf[1] = 0x68;
			sndbuf[5] = 3;
			sndbuf[20] = sndbuf[21] = 0x86;

			iResult = send(ConnectSocket, sndbuf, len_snd, 0);
			if (iResult == SOCKET_ERROR)
			{
				/*
				sprintf(infostr, "send failed #%d\n", WSAGetLastError());
				MessageBox(g_hMainDlg, infostr, "Error", MB_OK | MB_ICONERROR);
				SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)"Send fail!");
				waitfor_mutex(Mutex_RT);
				ppYX[station][0].yx.value = 0;
				release_mutex(Mutex_RT);
				*/
				break;
			}

			iResult = recv(ConnectSocket, rcvbuf, BUFLEN, 0);
			if (iResult == SOCKET_ERROR)
			{
				//printf("send failed with error: %d\n", WSAGetLastError());
				//ppYX[station][0].yx.value = 0;
				break;
			}
			if (iResult < 22)
			{
				Sleep(10);
				continue;
			}
			len_rcv = iResult;
			n_yc = rcvbuf[15] + 256 * rcvbuf[14];
			n_yx = rcvbuf[17] + 256 * rcvbuf[16] - n_yc;

			waitfor_mutex(Mutex_RT);
			for (i = 0; i < n_yc; i++)
			{
				if (i >= System.nYC - 1)
					break;
				ppYC[station][i + 1].yc.value = rcvbuf[19 + 2 * i] + 256 * rcvbuf[18 + 2 * i];
			}
			for (i = 0; i < n_yx; i++)
			{
				short new_value;
				struct date d;
				struct time t;
				ENEVENT event;

				if (i >= System.nYX - 1)
					break;
				new_value = rcvbuf[19 + 2 * (n_yc + i)] + 256 * rcvbuf[18 + 2 * (n_yc + i)];
				if (new_value == ppYX[station][i + 1].yx.value)
					continue;
				ppYX[station][i + 1].yx.value = new_value;

				sprintf(infostr, "遥信变位： (%d, %d) = %d", station, i + 1, new_value);
				//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
				DebugPrintln(infostr);

				// Event
				memset(&event, 0, sizeof(ENEVENT));

				event.type = EVENTTYPE_ALARM;
				event.subtype = EVENTSUBTYPE_SWITCH;
				event.status = new_value ? EVENTSTATUS_YXCHANGE1 : EVENTSTATUS_YXCHANGE0;

				event.dtype = VARTYPE_YX;
				event.station = station;
				event.point = i + 1;

				getdate(&d);
				event.date.year = d.da_year;
				event.date.day = d.da_day;
				event.date.month = d.da_mon;
				gettime(&t);
				event.time.hour = t.ti_hour;
				event.time.minute = t.ti_min;
				event.time.second = t.ti_sec;
				event.time.hundsec = t.ti_hund;

				waitfor_mutex(Mutex_EVENT);
				memcpy(pEventBuf + Num_Event, &event, sizeof(ENEVENT));
				Num_Event++;
				if (Num_Event == MAXNUM_EVENT)
					memcpy(pEventBuf, pEventBuf + 1, sizeof(ENEVENT)*(Num_Event - 1));
				release_mutex(Mutex_EVENT);
			}
			release_mutex(Mutex_RT);

			Sleep(200);
		}
		
		Sleep(10);
	}

	closesocket(ConnectSocket);

	sprintf(infostr, "#%d线程结束", station);
	//SendMessage(g_hMainDlg, UWM_SETDEBUGSTRING, 0, (LPARAM)infostr);
	DebugPrintln(infostr);

	//set_var(Flag_FER, -1);
	dec_var(Count_FER);

	return 0L;
}
